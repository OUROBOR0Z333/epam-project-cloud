name: '2.8.5 - Database Initialization'

on:
  workflow_dispatch:

env:
  TF_WORKSPACE: qa



jobs:
  deploy-database-init:
    runs-on: ubuntu-latest
    environment: qa
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.8.0

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Setup Ansible
      run: |
        pip install ansible

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}
        project_id: ${{ secrets.GCP_PROJECT_ID }}
        token_format: access_token

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2
      with:
        project_id: ${{ secrets.GCP_PROJECT_ID }}

    - name: Terraform Init
      run: |
        cd terraform
        terraform init \
          -backend-config="bucket=${{ secrets.TERRAFORM_STATE_BUCKET }}" \
          -backend-config="prefix=terraform/state"

    - name: Configure Terraform workspace
      run: |
        cd terraform
        unset TF_WORKSPACE
        terraform workspace select -or-create=true ${{ env.TF_WORKSPACE }}

    - name: Get Terraform Outputs
      id: tf-outputs
      run: |
        cd terraform
        set -euo pipefail  # abort on any unset var or non-zero exit
        
        # Refresh the state to ensure we have the latest outputs
        terraform refresh
        
        # Now that workspace is properly set, try to get the outputs
        DB_HOST=$(terraform output -raw database_connection_name)
        DB_NAME=$(terraform output -raw database_name)
        DB_USER=$(terraform output -raw database_user)
        DB_PASSWORD=$(terraform output -raw database_password)
        BACKEND_IP=$(terraform output -raw backend_internal_ip)
        
        # Write all outputs to GITHUB_OUTPUT
        echo "db_host=$DB_HOST" >> $GITHUB_OUTPUT
        echo "db_name=$DB_NAME" >> $GITHUB_OUTPUT
        echo "db_user=$DB_USER" >> $GITHUB_OUTPUT
        echo "db_password=$DB_PASSWORD" >> $GITHUB_OUTPUT
        echo "backend_ip=$BACKEND_IP" >> $GITHUB_OUTPUT
        
        # Sanity-check variables
        for v in DB_HOST DB_NAME DB_USER DB_PASSWORD BACKEND_IP; do
          printf '%-15s %s\n' "$v" "${!v}"
          [ -z "${!v}" ] && { echo "::error ::$v is empty"; exit 1; }
        done

    - name: Get OS Login SSH Username for Backend
      id: backend-user
      run: |
        set -euo pipefail  # abort on any unset var or non-zero exit
        
        echo "Environment variable: ${{ env.TF_WORKSPACE }}"
        echo "Project ID secret: ${{ secrets.GCP_PROJECT_ID }}"
        SERVICE_ACCOUNT_EMAIL="app-sa-${{ env.TF_WORKSPACE }}@${{ secrets.GCP_PROJECT_ID }}.iam.gserviceaccount.com"
        echo "Service account to impersonate: $SERVICE_ACCOUNT_EMAIL"
        
        BACKEND_SSH_USER=$(gcloud compute os-login describe-profile --format="value(response.posixAccounts.username)" --impersonate-service-account="$SERVICE_ACCOUNT_EMAIL")
        
        # Verify the SSH user was retrieved
        if [ -z "$BACKEND_SSH_USER" ]; then
          echo "::error ::Failed to retrieve OS Login SSH username"
          exit 1
        fi
        
        echo "BACKEND_USER=$BACKEND_SSH_USER" >> $GITHUB_OUTPUT
        
        # Confirm the value
        echo "Retrieved SSH username: $BACKEND_SSH_USER"

    - name: Create Ansible Inventory
      run: |
        set -euo pipefail  # abort on any unset var or non-zero exit
        
        mkdir -p ansible/inventory
        
        # Get values from previous steps
        BACKEND_IP="${{ steps.tf-outputs.outputs.backend_ip }}"
        BACKEND_USER="${{ steps.backend-user.outputs.BACKEND_USER }}"
        DB_HOST="${{ steps.tf-outputs.outputs.db_host }}"
        DB_NAME="${{ steps.tf-outputs.outputs.db_name }}"
        DB_USER="${{ steps.tf-outputs.outputs.db_user }}"
        DB_PASSWORD="${{ steps.tf-outputs.outputs.db_password }}"
        
        # Sanity-check variables before writing the inventory file
        for v in BACKEND_IP BACKEND_USER DB_HOST DB_NAME DB_USER DB_PASSWORD; do
          printf '%-15s %s\n' "$v" "${!v}"
          [ -z "${!v}" ] && { echo "::error ::$v is empty"; exit 1; }
        done
        
        # Create the inventory file with proper variable substitution
        # Using printf to avoid heredoc indentation issues in YAML
        {
        echo "[backend]"
        echo "$BACKEND_IP ansible_user=$BACKEND_USER ansible_ssh_common_args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'"
        echo ""
        echo "[backend:vars]"
        echo "ansible_python_interpreter=/usr/bin/python3"
        echo "db_connection_name=$DB_HOST"
        echo "db_host=127.0.0.1"
        echo "db_name=$DB_NAME"
        echo "db_user=$DB_USER"
        echo "db_password=$DB_PASSWORD"
        } > ansible/inventory/${{ env.TF_WORKSPACE }}_temp.ini


        echo 'Inventory generated:'
        cat ansible/inventory/${{ env.TF_WORKSPACE }}_temp.ini

    - name: Validate Ansible Inventory
      run: |
        set -euo pipefail
        ansible-inventory -i ansible/inventory/${{ env.TF_WORKSPACE }}_temp.ini --list
      env:
        ANSIBLE_HOST_KEY_CHECKING: False

    - name: Run Database Schema Initialization with Ansible
      run: |
        set -euo pipefail
        ansible-playbook -i ansible/inventory/${{ env.TF_WORKSPACE }}_temp.ini ansible/playbooks/database_init.yml \
          --extra-vars "db_host=127.0.0.1" \
          --extra-vars "db_name=${{ steps.tf-outputs.outputs.db_name }}" \
          --extra-vars "db_user=${{ steps.tf-outputs.outputs.db_user }}" \
          --extra-vars "db_password=${{ steps.tf-outputs.outputs.db_password }}"
      env:
        ANSIBLE_HOST_KEY_CHECKING: False